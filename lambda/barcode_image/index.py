import json
import boto3
from botocore.exceptions import ClientError
import os
import hashlib
import uuid
import base64
from aws_lambda_powertools import Logger, Tracer

tracer = Tracer()
logger = Logger()

bedrock = boto3.client("bedrock-runtime")
dynamodb = boto3.resource('dynamodb')
s3 = boto3.client('s3')


PRODUCT_SUMMARY_TABLE_NAME = os.environ['PRODUCT_SUMMARY_TABLE_NAME']
PRODUCT_TABLE_NAME = os.environ['PRODUCT_TABLE_NAME']
S3_BUCKET_NAME = os.environ['S3_BUCKET_NAME']

def generate_product_summary_prompt(
    user_preference_data, product_composition, product_name
):
    return f"""Human:
        You are a nutrition expert. I will give you a nutritional list of a product.
        Think before you identify the most unhealthy ingredient in the list of ingredients and write a prompt in English which will be used to generate an image in English. 
        The prompt is used to put in exerg the most unhealthy ingredient in the list alongside the product itself.
        Imagine the quantity of the most unhealthy component in terms of the quotient so that I realize how bad it is.
        Respond only with the prompt.
        -----------------------------------
        Example 1:  
        Nutritional list:
          "user_preference_data": "",
          "product_name": "Hazelnut and cocoa spread",
          "product_composition": 
            "energy-kj_100g": "2252",
            "fat_100g": "30,9",
            "carbohydrates_100g": "57,5",
            "sugars_100g": "56,3",
            "fiber_100g": "0",
            "proteins_100g": "6,3 g",
            "salt_100g": "0,107 g"
        
        Response: 
         A jar of chocolate hazelnut spread next to 14 cubes of sugar.
        
        -------------------------------------
        Example 2:
        Nutritional list:
            "user_preference_data": "",
            "categories": "Sandwichs, Hamburgers",
            "generic_name": "",
            "product_composition": 
                "energy-kj_100g": "988",
                "fat_100g": "12",
                "sugars_100g": "",
                "carbohydrates_100g": "19",
                "Sucres": "",
                "fiber_100g": "",
                "proteins_100g": "12,5",
                "salt_100g": "1,02"

        Response: "an hamburger and an evil teaspoon full of salt"
        -------------------------------------
        Example 3
        Liste nutritionnelle:
            "user_preference_data": "",
            "categories": "Snacks, Snacks salés, Amuse-gueules, Chips et frites, Chips, Tuiles salées, en:Texas bbq sauce flavour savoury snack",
            "generic_name": "",
            "product_composition": 
                "energy-kj_100g": "2177.0",
                "fat_100g": "29.0", 
                "saturated-fat_100g": "6.3", 
                "carbohydrates_100g": "57.0", 
                "sugars_100g": "4.6", 
                "fiber_100g": "3.5", 
                "proteins_100g": "6.1", 
                "salt_100g": "1.2"
        Response:  "barbecue potato chips and a salt shaker"

        -------------------------------------

        Example 4
        Liste nutritionnelle:
          "user_preference_data": "{user_preference_data}",
          "generic_name": "{product_name}",
          "product_composition": {product_composition}
        Assistant:"""

def query_bedrock(payload, model_id):
    try:
        response = bedrock.invoke_model(
            body=payload,
            modelId=model_id,
            contentType="application/json",
            accept="*/*",
        )
        logger.debug(response)
        input_token_count = response["ResponseMetadata"]["HTTPHeaders"]["x-amzn-bedrock-input-token-count"]
        output_token_count = response["ResponseMetadata"]["HTTPHeaders"]["x-amzn-bedrock-output-token-count"]
        logger.debug("Input_tokens = {}, Output_tokens = {}".format(input_token_count, output_token_count))

        return response
    except ClientError as error:
        logger.error(error.response)
    return None


    
def get_image(prompt):
    """
    Generate an image using Amazon Nova Canvas model.
    Args:
        body (str) : The request body to use.
    Returns:
        image_bytes (bytes): The image generated by the model.
    """
    body = json.dumps({
        "taskType": "TEXT_IMAGE",
        "textToImageParams": {
            "text": prompt,
            "negativeText": "text, labels, branding, human"
        }, 
        "imageGenerationConfig": {
            "numberOfImages": 1,
            "height": 1024,
            "width": 1024,
            "cfgScale": 8.0,
            "seed": 0
        }
    }) 

    response = bedrock.invoke_model(
        body=body,
        modelId='amazon.nova-canvas-v1:0',
        accept="application/json",
        contentType="application/json"
    )
    response_body = json.loads(response.get("body").read())

    base64_image = response_body.get("images")[0]
    base64_bytes = base64_image.encode('ascii')
    image_bytes = base64.b64decode(base64_bytes)

    finish_reason = response_body.get("error")
    if finish_reason is not None:
        logger.error("Error: generate_image", finish_reason)

    logger.debug("Successfully generated image")
    return image_bytes
    
def map(input_json):
    # Extracting product details
    product_details = input_json[0]
    
    # Mapping old keys to new keys
    mapping = {
        "energy-kj_100g": "Énergie",
        "fat_100g": "Matières grasses",
        "saturated-fat_100g": "Acides gras saturés",
        "carbohydrates_100g": "Glucides",
        "sugars_100g": "Sucres",
        "fiber_100g": "Fibres alimentaires",
        "proteins_100g": "Protéines",
        "salt_100g": "Sel"
    }
    
    # Create the new product composition
    product_composition = {mapping[key]: value for key, value in product_details.items() if key in mapping}
    return product_composition


def get_product_from_db(product_code, language):
    table = dynamodb.Table(PRODUCT_TABLE_NAME)

    try:
        response = table.get_item(
            Key={
                'product_code': product_code,
                'language' : language
            }
        )
        # Check if the item exists
        if 'Item' in response:
            item = response['Item']
            return item.get('product_name'), item.get('ingredients'), item.get('additives')
        else:
            return None, None, None
    except Exception as e:
        logger.error("Error: get_product_from_db", e)
        return None, None, None

def generate_combined_string(obj):
    concatenated_string = ''.join(str(key) for key in obj.keys())
    return concatenated_string
    
def calculate_hash(product_code, user_allergies, user_preference_data,  language):


    # Convert dictionaries to JSON strings
   
    user_allergies_str = generate_combined_string(user_allergies)
    user_preference_data_str = generate_combined_string(user_preference_data)

    # Concatenate the string representations of the variables
    concatenated_string = (
        product_code
        + user_allergies_str
        + user_preference_data_str
        + language
    )


    # Calculate the hash
    hashed_value = hashlib.sha256(concatenated_string.encode()).hexdigest()

    return hashed_value


def call_nova_micro(prompt_text):

    request_body = json.dumps({
        "inferenceConfig": {
            "max_new_tokens": 4096
        },
        "messages": [
            {
                "role": "user",
                "content": [
                    {
                    "text": prompt_text
                }
                ],
            }
        ]
    })

    response = bedrock.invoke_model(
        body=request_body,
        modelId="amazon.nova-micro-v1:0",
        accept="application/json",
        contentType="application/json"
    )
    response_body = json.loads(response.get("body").read())
    output = response_body.get("output", {})
    message = output.get("message", {})
    content = message.get("content", [])
    results = content[0].get("text") if content else None
    return results

def upload_image_to_s3(image_bytes):
    
    # Generate a random filename using UUID
    file_name = str(uuid.uuid4()) + ".jpg"

    s3_key = "img/" + file_name

    s3.put_object(Body=image_bytes, Bucket=S3_BUCKET_NAME, Key=s3_key)

    logger.debug("Uploaded image: " + file_name)

    return f"img/{file_name}"

class ProductNotFoundException(Exception):
    pass

def put_product_image_to_dynamodb(product_code, params_hash, image_url):
    # Get reference to the table
    table = dynamodb.Table(PRODUCT_SUMMARY_TABLE_NAME)

    # Perform the update operation
    response = table.update_item(
        Key={
            'product_code': product_code,
            'params_hash': params_hash
        },
        UpdateExpression="SET imageUrl = :url",  # Update the imageUrl attribute
        ExpressionAttributeValues={
            ':url': image_url  # Specify the new imageUrl value
        }
    )

    # Return the response
    return response

def get_image_url(product_code, params_hash):
    # Get reference to the table
    logger.debug("PRODUCT_SUMMARY_TABLE_NAME="+PRODUCT_SUMMARY_TABLE_NAME)
    table = dynamodb.Table(PRODUCT_SUMMARY_TABLE_NAME)
    logger.debug("GET imageUrl, product_code="+product_code+", params_hash="+params_hash)
    # Perform a query to retrieve the item
    response = table.get_item(
        Key={
            'product_code': product_code,
            'params_hash': params_hash
        },
        ConsistentRead=True
        
    )
    logger.debug(response)
    # Check if the 'imageUrl' attribute exists in the response
    if 'Item' in response:
        if 'imageUrl' in response['Item']:
            return response['Item']['imageUrl']  # Return the imageUrl if it exists
    return None  # Return None if imageUrl does not exist

@logger.inject_lambda_context(log_event=True)
def handler(event, context):
    logger.info(event)

    try:
        body = event.get("body")
        json_body = json.loads(body)
        product_code = json_body.get("productCode")
        language = json_body.get("language")

        user_preference_data = json_body.get("preferences")
        user_allergies = json_body.get("allergies")

        product_name, product_ingredients, product_additives = get_product_from_db(product_code, language)

        if product_name is not None:
            logger.debug("Product found in the database")
            hash_value = calculate_hash(product_code, user_allergies, user_preference_data, language)
            image_url = get_image_url(product_code, hash_value)
            if image_url:
                logger.debug("Image URL exists for the product_code and params_hash.")
            else:
                logger.debug("Image URL does not exist yet for the product_code and params_hash.")
                prompt_text = generate_product_summary_prompt(
                    user_preference_data, product_ingredients, product_name
                )

                image_generated_prompt = call_nova_micro(prompt_text)
            
                base64_image = get_image(image_generated_prompt)
                image_url = upload_image_to_s3(base64_image)
                put_product_image_to_dynamodb(product_code, hash_value, image_url)

            response = {"imageUrl": "/" + image_url}

            return {
                "statusCode": 200, 
                "body": json.dumps(response), 
                "headers": {
                    "Access-Control-Allow-Headers": "*",
                    "Access-Control-Allow-Origin": "*",
                    "Access-Control-Allow-Methods": "OPTIONS,POST,GET",
                }
            }

        else:
            logger.debug("Product not found in the database")
            raise ProductNotFoundException("Product not found.")
    except Exception as e:
            logger.error("Error:", e)
            return {
            "statusCode": 500,
            "body": json.dumps({"error": "Unwnown error"}),
            "headers": {
                "Access-Control-Allow-Headers": "*",
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Methods": "OPTIONS,POST,GET",
            },
        }
   

