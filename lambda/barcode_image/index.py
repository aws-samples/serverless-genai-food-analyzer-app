import json
import boto3
from botocore.exceptions import ClientError
import os
import hashlib
import uuid
import base64
from aws_lambda_powertools import Logger, Tracer

tracer = Tracer()
logger = Logger()

bedrock = boto3.client("bedrock-runtime")
dynamodb = boto3.resource('dynamodb')
s3 = boto3.client('s3')


PRODUCT_SUMMARY_TABLE_NAME = os.environ['PRODUCT_SUMMARY_TABLE_NAME']
PRODUCT_TABLE_NAME = os.environ['PRODUCT_TABLE_NAME']
S3_BUCKET_NAME = os.environ['S3_BUCKET_NAME']

def generate_product_summary_prompt(
    user_preference_data, product_composition, product_name
):
    return f"""Human:
        You are a nutrition expert. I will give you a nutritional list of a product, as sold per 100 g / 100 ml.
        What, in your opinion, is the most unhealthy component? You must imagine the quantity of the most unhealthy component in terms of the quotient so that I realize how bad it is.
        Respond in the form of a prompt in English, which will be used to generate an image in English. Respond only with the prompt.
        -----------------------------------
        Example 1:  
        Nutritional list:
          "user_preference_data": "",
          "product_name": "Hazelnut and cocoa spread",
          "product_composition": 
            "energy-kj_100g": "2252",
            "fat_100g": "30,9",
            "carbohydrates_100g": "57,5",
            "sugars_100g": "56,3",
            "fiber_100g": "0",
            "proteins_100g": "6,3 g",
            "salt_100g": "0,107 g"
        
        Response: 
         A jar of chocolate hazelnut spread next to 14 cubes of sugar labeled "diabetes danger".
        
        -------------------------------------
        Example 2:
        Nutritional list:
            "user_preference_data": "",
            "categories": "Sandwichs, Hamburgers",
            "generic_name": "",
            "product_composition": 
                "energy-kj_100g": "988",
                "fat_100g": "12",
                "sugars_100g": "",
                "carbohydrates_100g": "19",
                "Sucres": "",
                "fiber_100g": "",
                "proteins_100g": "12,5",
                "salt_100g": "1,02"

        Response: "an hamburger and an evil teaspoon full of salt"
        -------------------------------------
        Example 3
        Liste nutritionnelle:
            "user_preference_data": "",
            "categories": "Snacks, Snacks salés, Amuse-gueules, Chips et frites, Chips, Tuiles salées, en:Texas bbq sauce flavour savoury snack",
            "generic_name": "",
            "product_composition": 
                "energy-kj_100g": "2177.0",
                "fat_100g": "29.0", 
                "saturated-fat_100g": "6.3", 
                "carbohydrates_100g": "57.0", 
                "sugars_100g": "4.6", 
                "fiber_100g": "3.5", 
                "proteins_100g": "6.1", 
                "salt_100g": "1.2"
        Response:  "barbecue potato chips and a salt shaker"

        -------------------------------------

        Example 4
        Liste nutritionnelle:
          "user_preference_data": "{user_preference_data}",
          "generic_name": "{product_name}",
          "product_composition": {product_composition}
        Assistant:"""

def get_bedrock_text_reponse(response):
    response_body = json.loads(response.get("body").read())

    text = response_body.get("content")[0].get("text")
    

    return text


def query_bedrock(payload, model_id):
    try:
        response = bedrock.invoke_model(
            body=payload,
            modelId=model_id,
            contentType="application/json",
            accept="*/*",
        )
        logger.debug(response)
        input_token_count = response["ResponseMetadata"]["HTTPHeaders"]["x-amzn-bedrock-input-token-count"]
        output_token_count = response["ResponseMetadata"]["HTTPHeaders"]["x-amzn-bedrock-output-token-count"]
        logger.debug("Input_tokens = {}, Output_tokens = {}".format(input_token_count, output_token_count))

        return response
    except ClientError as error:
        logger.error(error.response)
    return None

    
    
def get_image(prompt):
    """
    Generate an image using SDXL 1.0 on demand.
    Args:
        model_id (str): The model ID to use.
        body (str) : The request body to use.
    Returns:
        image_bytes (bytes): The image generated by the model.
    """

    body=json.dumps({
        "text_prompts": [
        {
        "text": prompt
        }
    ],
    "cfg_scale": 10,
    "seed": 0,
    "steps": 35,
    "samples" : 1,
    "style_preset" : "photographic"
    })

   
    accept = "application/json"
    content_type = "application/json"
    model_id = 'stability.stable-diffusion-xl-v1'

    logger.debug("Generating image with SDXL model ", model_id)

    response = bedrock.invoke_model(
        body=body, modelId=model_id, accept=accept, contentType=content_type
    )
    response_body = json.loads(response.get("body").read())

    base64_image = response_body.get("artifacts")[0].get("base64")

    logger.debug("Successfully generated image withvthe SDXL 1.0 model %s", model_id)

    return base64_image
    
    
def map(input_json):
    # Extracting product details
    product_details = input_json[0]
    
    # Mapping old keys to new keys
    mapping = {
        "energy-kj_100g": "Énergie",
        "fat_100g": "Matières grasses",
        "saturated-fat_100g": "Acides gras saturés",
        "carbohydrates_100g": "Glucides",
        "sugars_100g": "Sucres",
        "fiber_100g": "Fibres alimentaires",
        "proteins_100g": "Protéines",
        "salt_100g": "Sel"
    }
    
    # Create the new product composition
    product_composition = {mapping[key]: value for key, value in product_details.items() if key in mapping}
    return product_composition


def get_product_from_db(product_code, language):
    table = dynamodb.Table(PRODUCT_TABLE_NAME)

    try:
        response = table.get_item(
            Key={
                'product_code': product_code,
                'language' : language
            }
        )
        # Check if the item exists
        if 'Item' in response:
            item = response['Item']
            return item.get('product_name'), item.get('ingredients'), item.get('additives')
        else:
            return None, None, None
    except Exception as e:
        logger.error("Error: get_product_from_db", e)
        return None, None, None

def generate_combined_string(obj):
    concatenated_string = ''.join(str(key) for key in obj.keys())
    return concatenated_string
    
def calculate_hash(product_code, user_allergies, user_preference_data,  language):


    # Convert dictionaries to JSON strings
   
    user_allergies_str = generate_combined_string(user_allergies)
    user_preference_data_str = generate_combined_string(user_preference_data)

    # Concatenate the string representations of the variables
    concatenated_string = (
        product_code
        + user_allergies_str
        + user_preference_data_str
        + language
    )


    # Calculate the hash
    hashed_value = hashlib.sha256(concatenated_string.encode()).hexdigest()

    return hashed_value


def call_bedrock(prompt_text):

    prompt_config = {
        "anthropic_version": "bedrock-2023-05-31",
        "max_tokens": 10000,
        "temperature": 0.5,
        "top_p": 0.9,
        "messages": [
            {
                "role": "user",
                "content": [
                    {
                    "type": "text",
                    "text": prompt_text
                }
                ],
            }
        ],
    }

    body = json.dumps(prompt_config)

    modelId = "anthropic.claude-3-haiku-20240307-v1:0"

    response = get_bedrock_text_reponse(
            query_bedrock(payload=body, model_id=modelId)
    )
    
    return response

def upload_image_to_s3(image_bytes):
    
    # Generate a random filename using UUID
    file_name = str(uuid.uuid4()) + ".jpg"

    s3_key = "img/" + file_name

    s3.put_object(Body=image_bytes, Bucket=S3_BUCKET_NAME, Key=s3_key)

    logger.debug("Uploaded image:", file_name)

    return f"img/{file_name}"

class ProductNotFoundException(Exception):
    pass

def put_product_image_to_dynamodb(product_code, params_hash, image_url):
    # Get reference to the table
    table = dynamodb.Table(PRODUCT_SUMMARY_TABLE_NAME)

    # Perform the update operation
    response = table.update_item(
        Key={
            'product_code': product_code,
            'params_hash': params_hash
        },
        UpdateExpression="SET imageUrl = :url",  # Update the imageUrl attribute
        ExpressionAttributeValues={
            ':url': image_url  # Specify the new imageUrl value
        }
    )

    # Return the response
    return response

def get_image_url(product_code, params_hash):
    # Get reference to the table
    logger.debug("PRODUCT_SUMMARY_TABLE_NAME="+PRODUCT_SUMMARY_TABLE_NAME)
    table = dynamodb.Table(PRODUCT_SUMMARY_TABLE_NAME)
    logger.debug("GET imageUrl, product_code="+product_code+", params_hash="+params_hash)
    # Perform a query to retrieve the item
    response = table.get_item(
        Key={
            'product_code': product_code,
            'params_hash': params_hash
        },
        ConsistentRead=True
        
    )
    logger.debug(response)
    # Check if the 'imageUrl' attribute exists in the response
    if 'Item' in response:
        if 'imageUrl' in response['Item']:
            return response['Item']['imageUrl']  # Return the imageUrl if it exists
    return None  # Return None if imageUrl does not exist

@logger.inject_lambda_context(log_event=True)
def handler(event, context):
    logger.info(event)

    try:
        body = event.get("body")
        json_body = json.loads(body)
        product_code = json_body.get("productCode")
        language = json_body.get("language")

        user_preference_data = json_body.get("preferences")
        user_allergies = json_body.get("allergies")

        product_name, product_ingredients, product_additives = get_product_from_db(product_code, language)

        if product_name is not None:
            logger.debug("Product found in the database")
            hash_value = calculate_hash(product_code, user_allergies, user_preference_data, language)
            image_url = get_image_url(product_code, hash_value)
            if image_url:
                logger.debug("Image URL exists for the product_code and params_hash.")
            else:
                logger.debug("Image URL does not exist yet for the product_code and params_hash.")
                prompt_text = generate_product_summary_prompt(
                    user_preference_data, product_ingredients, product_name
                )

                image_generated_prompt = call_bedrock(prompt_text)
            
                base64_image = get_image(image_generated_prompt)
                image_data = base64.b64decode(base64_image)
                image_url = upload_image_to_s3(image_data)
                put_product_image_to_dynamodb(product_code, hash_value, image_url)

            response = {"imageUrl": "/" + image_url}
            logger.debug("Response", extra=response)

            return {
                "statusCode": 200, 
                "body": json.dumps(response), 
                "headers": {
                    "Access-Control-Allow-Headers": "*",
                    "Access-Control-Allow-Origin": "*",
                    "Access-Control-Allow-Methods": "OPTIONS,POST,GET",
                }
            }

        else:
            logger.debug("Product not found in the database")
            raise ProductNotFoundException("Product not found.")
    except Exception as e:
            logger.error("Error:", e)
            return {
            "statusCode": 500,
            "body": json.dumps({"error": "Unwnown error"}),
            "headers": {
                "Access-Control-Allow-Headers": "*",
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Methods": "OPTIONS,POST,GET",
            },
        }
   

